<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>FW4SPL</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><meta name="author" content="Flavien Bridault"></meta><meta name="description" content="Ogre 3D integration in FW4SPL"></meta><meta name="keywords" content="presentation"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="css/presentation.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="750"><div class="step step-level-1" step="0" id="circle-no-background" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><div class="line-block"><br></br><br></br><br></br><br></br></div><h1 id="ogre-3d-in-fw4spl">Ogre 3D in FW4SPL</h1><p><strong>Flavien Bridault</strong></p><div class="line-block"><br></br></div><p><em>Training - Strasbourg, 22nd January 2016</em></p></div><div class="step step-level-1 overview" step="1" data-x="2000" data-scale="1.0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-y="0" data-z="0"><h1 id="overview">Overview</h1><ul><li><dl><dt><em>Ogre 3D</em></dt><dd><ul><li>Architecture overview</li><li>Scripting</li></ul></dd></dl></li><li><dl><dt>Generic scene</dt><dd><ul><li>Architecture</li><li>Basics</li><li>Adaptors</li><li>Transparency</li></ul></dd></dl></li><li>Perspectives</li><li><dl><dt>Tutorials</dt><dd><ul><li>Material</li><li>Compositors</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="2" data-x="2000" data-y="2700" data-rotate-z="90" data-rotate-x="0" data-rotate-y="0" data-scale="1.0" data-z="0"><h1 id="ogre-3d">Ogre 3D</h1><h2 id="history">History</h2><ul><li>Object-Oriented Graphics Rendering Engine</li><li>Started in 2000, first release in 2005</li><li>Latest stable 1.9 (2013), preview 2.1</li><li><dl><dt>Used in free or commercial games</dt><dd><ul><li>Ankh series (2005-2009)</li><li>TorchLight I (2009)</li><li>Zombie Driver (2009)</li><li>TorchLight II (2012-2015)</li></ul></dd></dl></li></ul><div class="notes"><ul><li>Rendering Engine, not actually a game engine</li></ul></div></div><div class="step step-level-1 text-medium" step="3" data-y="4200" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-z="0"><h1 id="id1">Ogre 3D</h1><h2 id="features">Features</h2><ul><li>High-level abstractions</li><li>Cross-platform : Windows, Linux, MacOSX and Android</li><li>Scene-graph</li><li>Resource management (meshes, textures, material/shaders)</li><li>Vertex animation (CPU and GPU)</li><li>Material LOD</li><li>Material scripting</li><li>Multipass effects</li><li>Progressive meshes (manual or auto)</li><li>Shadows (image or object-based)</li><li>Compositors</li><li>Particles system</li><li>Ribbon trails</li><li>BSP/PVS, Octree, portals</li></ul><div class="notes"><ul><li>Texture == image</li></ul></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="5700" data-z="0"><h1 id="id2">Ogre 3D</h1><h2 id="why">Why ?</h2><ul><li><dl><dt>VTK</dt><dd><ul><li>is oriented towards visualization</li><li>is far from the hardware, very high-level abstraction</li><li>does not use cutting-edge OpenGL features</li></ul></dd></dl></li><li><dl><dt>Other</dt><dd><ul><li>Unreal, Unity</li><li>Irrlicht</li><li>G3D</li></ul></dd></dl></li></ul></div><div class="step step-level-1 title" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="7200" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="architecture-overview">Architecture overview</h1></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="8700" data-z="0"><h1 id="id3">Ogre 3D</h1><h2 id="id4">Architecture overview</h2><img src="images/ogre-uml-overview.png" width="100%"></img></div><div class="step step-level-1" step="7" data-y="8700" data-x="1900" data-scale="0.75" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-z="0"></div><div class="step step-level-1" step="8" data-x="1900" data-y="10400" data-scale="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-z="0"><h1 id="id5">Ogre 3D</h1><h2 id="ogre-root">::Ogre::Root</h2><ul><li>Entry point in the Ogre system</li><li>First to be created, last to be deleted</li><li>Holds scene and resource managers</li><li>Holds the render system</li><li>Triggers the rendering of frames (continuous or on demand)</li></ul></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="12100" data-z="0"><h1 id="id6">Ogre 3D</h1><h2 id="ogre-rendersystem">::Ogre::RenderSystem</h2><ul><li>Abstraction of the underlying 3D API (DirectX/OpenGL)</li><li>Used to create render windows <em>::Ogre::RenderWindow</em></li><li><dl><dt>Instantiated dynamically by selecting a shared library</dt><dd><ul><li>DirectX9</li><li>DirectX11</li><li>OpenGL</li><li>OpenGL3+</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="13800" data-z="0"><h1 id="id7">Ogre 3D</h1><h2 id="ogre-scenemanager">::Ogre::SceneManager</h2><ul><li><dl><dt>Organize the content of the 3D scene through a graph :</dt><dd><ul><li>objects</li><li>cameras</li><li>lights</li></ul></dd></dl></li><li>Differents spatial structures used (BSP, PVS, etc...) according to the scene type</li><li>Responsible of selecting the objects to be rendered each frame</li></ul></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="15500" data-z="0"><h1 id="id8">Ogre 3D</h1><h2 id="ogre-entity">::Ogre::Entity</h2><ul><li>Movable or static object in the scene</li><li>Attached to a <em>::Ogre::SceneNode</em></li><li>Instantiation of a mesh in the 3D scene</li><li>A mesh may have multiple materials : for each <em>::Ogre::SubMesh</em>, a <em>::Ogre::SubEntity</em> is created in the entity</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="17200" data-z="0"><h1 id="id9">Ogre 3D</h1><h2 id="ogre-material">::Ogre::Material</h2><ul><li><dl><dt>Render states</dt><dd><ul><li>depth buffer test/write</li><li>culling/mode</li><li>blending equation</li><li>polygon fill mode (point, wireframe, solid)</li><li>...</li></ul></dd></dl></li><li><dl><dt>Shader</dt><dd><ul><li>vertex</li><li>hull</li><li>domain</li><li>geometry</li><li>fragment</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="18900" data-z="0"><h1 id="id10">Ogre 3D</h1><h2 id="ogre-resourcegroupmanager">::Ogre::ResourceGroupManager</h2><ul><li><dl><dt>one for each resource type:</dt><dd><ul><li>MeshManager</li><li>MaterialManager</li><li>TextureManager</li><li>CompositorManager</li></ul></dd></dl></li><li>allows to create/load/unload/destroy resources</li><li>few direct interactions, called by other parts of the Ogre system</li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="20600" data-z="0"><h1 id="id11">Ogre 3D</h1><h2 id="id12">::Ogre::ResourceGroupManager</h2><ul><li><dl><dt>Resources are created by name, looking through registered resource locations</dt><dd><ul><li><strong>::Ogre::ResourceGroupManager::addResourceLocation()</strong></li><li>configured easily from <em>::Ogre::ConfigFile</em> (<strong>.cfg</strong>)</li></ul></dd></dl></li></ul><pre class="highlight code"># resources.cfg

[compositors]
FileSystem=./Bundles/material_0-1/Media/compositors

[materials]
FileSystem=./Bundles/material_0-1/Media/materials/
FileSystem=./Bundles/materialExt_0-1/Media/materials/

[textures]
FileSystem=./Bundles/material_0-1/Media/textures/</pre></div><div class="step step-level-1 title" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="22300" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="scripting">Scripting</h1></div><div class="step step-level-1 text-small" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="24000" data-z="0"><h1 id="id13">Ogre 3D</h1><h2 id="materials">Materials</h2><pre class="highlight code">// dummy.material

vertex_program dummy_VP glsl
{
    source dummy_VP.glsl
    default_params
    {
        param_named_auto u_worldViewProj worldviewproj_matrix
    }
}

fragment_program dummy_FP glsl
{
    source dummy_FP.glsl
}

material dummy
{
    technique
    {
        pass
        {
            cull_hardware none
            depth_write on
            polygon_mode wireframe

            vertex_program_ref dummy_VP
            {
            }

            fragment_program_ref dummy_FP
            {
            }

            texture_unit
            {
                texture image.png
            }
        }
    }
}</pre></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="25700" data-z="0"><h1 id="id14">Ogre 3D</h1><h2 id="id15">Materials</h2><ul><li>Materials are parsed from (<strong>.material</strong>) files from the registered resource locations</li><li><dl><dt>GLSL programs can be written in a <strong>.material</strong> file</dt><dd><ul><li>be careful of the parsing order if you share programs accross multiple files</li><li>they can be put in <strong>.program</strong>, read before all <strong>.material</strong></li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="27400" data-z="0"><h1 id="id16">Ogre 3D</h1><h2 id="id17">Materials</h2><ul><li>Once parsed during initialization, easy to use:</li></ul><pre class="highlight code cpp"><span class="n">entity</span><span class="o">-&gt;</span><span class="n">setMaterialName</span><span class="p">(</span><span class="s">"dummy"</span><span class="p">);</span></pre><ul><li>Documentation: <a href="http://www.ogre3d.org/docs/manual/manual_14.html#Material-Scripts">http://www.ogre3d.org/docs/manual/manual_14.html#Material-Scripts</a></li></ul></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1900" data-y="29100" data-z="0"><h1 id="id18">Ogre 3D</h1><h2 id="compositors">Compositors</h2><ul><li><dl><dt>Pipeline of successive rendering passes:</dt><dd><ul><li>geometric pass</li><li>full screen pass</li></ul></dd></dl></li></ul><img src="images/compositor_sample.svg" width="80%"></img></div><div class="step step-level-1 text-small" step="20" data-x="1000" data-y="29100" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-z="0"><pre class="highlight code">compositor Edges
{
    technique
    {
        texture Scene target_width target_height PF_R8G8B8
        texture Edges target_width_scaled 0.5 target_target_height_scaled 0.5 PF_FLOAT16_R

        target Scene
        {
            input none
            pass clear
            {
            }

            pass render_scene
            {
            }
        }

        target Edges
        {
            input none

            pass render_quad
            {
                material EdgeDetection
                input 0 Scene
            }
        }

        target_output
        {
            input none

            pass render_quad
            {
                material BlendEdges
                input 0 Scene
                input 1 Edges
            }
        }
    }
}</pre></div><div class="step step-level-1" step="21" data-x="1000" data-y="30600" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="id19">Ogre 3D</h1><h2 id="id20">Compositors</h2><ul><li>Compositors can be chained together:</li></ul><pre class="highlight code">// Next.compositor
compositor Next
{
    ...
    target dummy
    {
        input previous

        ...
    }
    ...
}</pre><pre class="highlight code cpp"><span class="c1">// .cpp
</span><span class="k">auto</span> <span class="n">manager</span> <span class="o">=</span> <span class="o">::</span><span class="n">Ogre</span><span class="o">::</span><span class="n">CompositorManager</span><span class="o">::</span><span class="n">getSingletonPtr</span><span class="p">();</span>
<span class="n">manager</span><span class="o">-&gt;</span><span class="n">addCompositor</span><span class="p">(</span><span class="n">viewport</span><span class="p">,</span> <span class="s">"Edges"</span><span class="p">);</span>
<span class="n">manager</span><span class="o">-&gt;</span><span class="n">addCompositor</span><span class="p">(</span><span class="n">viewport</span><span class="p">,</span> <span class="s">"Next"</span><span class="p">);</span>
<span class="n">manager</span><span class="o">-&gt;</span><span class="n">setCompositorEnabled</span><span class="p">(</span><span class="n">viewport</span><span class="p">,</span> <span class="s">"Edges"</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">manager</span><span class="o">-&gt;</span><span class="n">setCompositorEnabled</span><span class="p">(</span><span class="n">viewport</span><span class="p">,</span> <span class="s">"Next"</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span></pre></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="1000" data-y="32100" data-z="0"><h1 id="id21">Ogre 3D</h1><h2 id="id22">Compositors</h2><ul><li>render_scene passes can select a technique in the material</li></ul><pre class="highlight code">// .compositor
target dummy
{
    material_scheme tutuScheme

    pass render_scene
    {
    }
}</pre></div><div class="step step-level-1" step="23" data-x="200" data-y="32100" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-z="0"><pre class="highlight code">// .material
material toto
{
    technique
    {
        pass
        {
            vertex_program_ref default_VP
            {
            }

            fragment_program_ref default_FP
            {
            }
        }
    }

    technique tutu
    {
        scheme tutuScheme

        pass
        {
            vertex_program_ref tutu_VP
            {
            }

            fragment_program_ref tutu_FP
            {
            }
        }
    }
}</pre></div><div class="step step-level-1" step="24" data-x="200" data-y="33600" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="id23">Ogre 3D</h1><h2 id="id24">Compositors</h2><ul><li>Documentation:</li></ul><p><a href="http://www.ogre3d.org/docs/manual/manual_29.html#Compositor-Scripts">http://www.ogre3d.org/docs/manual/manual_29.html#Compositor-Scripts</a></p><ul><li><dl><dt>Limitation:</dt><dd><ul><li>With the current v1.10, it is not possible to retrieve a depth buffer</li><li>Forced to use an extra floating-point buffer</li><li>Supported with 2.0 and 2.1</li></ul></dd></dl></li></ul></div><div class="step step-level-1 overview" step="25" data-x="200" data-y="36300" data-rotate-z="180" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="id25">Overview</h1><ul><li><dl><dt>Ogre 3D</dt><dd><ul><li>Architecture overview</li><li>Scripting</li></ul></dd></dl></li><li><dl><dt><em>Generic scene</em></dt><dd><ul><li>Architecture</li><li>Basics</li><li>Adaptors</li><li>Transparency</li></ul></dd></dl></li><li>Perspectives</li><li><dl><dt>Tutorials</dt><dd><ul><li>Material</li><li>Compositors</li></ul></dd></dl></li></ul></div><div class="step step-level-1 title" step="26" data-x="-1800" data-y="36300" data-rotate-z="180" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="generic-scene-architecture">Generic scene architecture</h1></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-3800" data-y="36300" data-z="0"><h1 id="generic-scene">Generic scene</h1><h2 id="architecture">Architecture</h2><p>Same principle than our generic scene using VTK</p><ul><li>A <strong>render</strong> service, working on a ::fwData::Composite data, acts as a manager</li><li>Sub-services named as <em>adaptors</em> work on the <strong>keys</strong> of the composite</li><li>Adaptors are configured in XML or instantiated by the C++ code</li><li>The manager listens to its composite, and supervises the starting and stopping of adaptors</li><li>When an object is added/removed, the adaptor in the XML configuration is started/stopped</li></ul></div><div class="step step-level-1" step="28" data-x="-3800" data-y="35400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericSceneOgre"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        <span class="nt">&lt;background</span> <span class="na">topColor=</span><span class="s">"#DDDDDD"</span> <span class="na">bottomColor=</span><span class="s">"#43958D"</span> <span class="na">topScale=</span><span class="s">"0.7"</span> <span class="na">bottomScale=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;renderer</span> <span class="na">id=</span><span class="s">"default"</span> <span class="na">layer=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"cameraAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SCamera"</span> <span class="na">objectId=</span><span class="s">"cameraTF"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTF"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"transformAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::STransform"</span> <span class="na">objectId=</span><span class="s">"transform"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTF"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span>

<span class="nt">&lt;item</span> <span class="na">key=</span><span class="s">"cameraTF"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;object</span> <span class="na">uid=</span><span class="s">"cameraTF"</span> <span class="na">type=</span><span class="s">"::fwData::TransformationMatrix3D"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/item&gt;</span>

<span class="nt">&lt;item</span> <span class="na">key=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;object</span> <span class="na">uid=</span><span class="s">"meshUid"</span> <span class="na">type=</span><span class="s">"::fwData::Mesh"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/item&gt;</span>

<span class="nt">&lt;item</span> <span class="na">key=</span><span class="s">"transform"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;object</span> <span class="na">uid=</span><span class="s">"transformUid"</span> <span class="na">type=</span><span class="s">"::fwData::TransformationMatrix3D"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/item&gt;</span></pre></div><div class="step step-level-1 text-medium" step="29" data-x="-5800" data-y="35400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="id26">Generic scene</h1><h2 id="library-design">Library design</h2><ul><li><dl><dt>the library <em>fwRenderOgre</em> contains the core</dt><dd><ul><li>SRender service</li><li>Interactors</li></ul></dd></dl></li><li>the bundle <em>visu</em> allows to register SRender</li><li>the bundle <em>visuOgreQt</em> contains the Qt widget and its interactions</li><li><dl><dt>the bundle <em>visuOgreAdaptor</em> contains the core adaptors</dt><dd><ul><li>SCamera</li><li>STransform</li><li>SMesh</li><li>SMaterial</li><li>SNegato</li><li>STexture</li><li>...</li></ul></dd></dl></li></ul></div><div class="step step-level-1 title" step="30" data-x="-7800" data-y="35400" data-rotate-z="180" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="basics">Basics</h1></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-9800" data-y="35400" data-z="0"><h1 id="id27">Generic scene</h1><h2 id="windowing-management">Windowing management</h2><img src="images/srender_interactor.svg" width="100%"></img></div><div class="step step-level-1" step="32" data-x="-9800" data-y="36400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="id28">Generic scene</h1><h2 id="visuogreqt-window">::visuOgreQt::Window</h2><ul><li><dl><dt>Create and manage the RenderWindow</dt><dd><ul><li>There is some shi**** platform-specific code</li></ul></dd></dl></li><li>Responsible of triggering the rendering (on-demand)</li><li>Receive mouse and keyboards interactions, forward them to the RenderWindowInteractorManager</li></ul></div><div class="step step-level-1" step="33" data-x="-9800" data-y="35400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"></div><div class="step step-level-1" step="34" data-x="-9800" data-y="34400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="id29">Generic scene</h1><h2 id="visuogreqt-renderwindowinteractormanager">::visuOgreQt::RenderWindowInteractorManager</h2><ul><li>Create ::visuOgreQt::Window and place it the GUI layout</li><li><dl><dt>Manage communication with Qt and fw4spl slots</dt><dd><ul><li><em>::fwRenderOgre::SRender</em></li><li><em>::visuOgreQt::Window</em></li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="35" data-x="-9800" data-y="35400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"></div><div class="step step-level-1" step="36" data-x="-11300" data-y="35400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="id30">Generic scene</h1><h2 id="fwrenderogre-srender">::fwRenderOgre::SRender</h2><ul><li>Contains and manages the adaptors</li><li>Bridge between the adaptors and the widget</li><li>With <strong>makeCurrent()</strong>, allows the adaptors to set the current OpenGL context</li><li>With <strong>requestRender()</strong>, allows the adaptors to refresh the rendering</li></ul></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-12800" data-y="35400" data-z="0"><h1 id="id31">Generic scene</h1><h2 id="layers">Layers</h2><img src="images/srender_layer.svg" width="100%"></img></div><div class="step step-level-1" step="38" data-x="-12800" data-y="36400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="id32">Generic scene</h1><h2 id="layer">Layer</h2><ul><li>Allows to have multiple scenes in a window</li><li>A scene is rendered individually in a render target (<em>::Ogre::Viewport</em>)</li><li>The output is only a color texture, thus SRender composite them at the end</li></ul><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericScene"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        <span class="nt">&lt;renderer</span> <span class="na">id=</span><span class="s">"video"</span> <span class="na">layer=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;renderer</span> <span class="na">id=</span><span class="s">"scene"</span> <span class="na">layer=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
        ...

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"videoAdapter"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SVideo"</span> <span class="na">objectId=</span><span class="s">"image"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"video"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"modelSeries"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SModelSeries"</span> <span class="na">objectId=</span><span class="s">"model"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"scene"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span></pre></div><div class="step step-level-1" step="39" data-x="-12800" data-y="35400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"></div><div class="step step-level-1" step="40" data-x="-12800" data-y="34400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="id33">Generic scene</h1><h2 id="interactors">Interactors</h2><ul><li><dl><dt>Two types :</dt><dd><ul><li>How to pick objects : mesh, video</li><li>How to move the camera : trackball, fixed, negato2D</li></ul></dd></dl></li><li>Selected with <em>::visuOgreAdaptor::SInteractorStyle</em></li></ul><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericScene"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        ...
        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"adaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SInteractorStyle"</span> <span class="na">objectId=</span><span class="s">"self"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">style=</span><span class="s">"Trackball"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>
        ...
    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span></pre></div><div class="step step-level-1" step="41" data-x="-12800" data-y="35400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"></div><div class="step step-level-1" step="42" data-x="-14600" data-y="35400" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="id34">Generic scene</h1><h2 id="id35">Compositors</h2><ul><li><em>DefaultCompositor</em> handles the "core" compositors, like those related to transparency</li><li>Each layer has a compositor chain managed by a <em>CompositorChainManager</em>, designed to receive custom compositors</li></ul><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericScene"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        <span class="nt">&lt;renderer</span> <span class="na">id=</span><span class="s">"video"</span> <span class="na">layer=</span><span class="s">"1"</span> <span class="na">compositors=</span><span class="s">"Laplace;ASCII;Bloom"</span> <span class="nt">/&gt;</span>
        ...
    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span></pre></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-16400" data-y="35400" data-z="0"><h1 id="id36">Generic scene</h1><h2 id="background">Background</h2><ul><li>Special layer #0, instantiated in SRender</li><li>Can be filled with a gradient</li></ul><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericScene"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        <span class="nt">&lt;background</span> <span class="na">topColor=</span><span class="s">"#DDDDDD"</span> <span class="na">bottomColor=</span><span class="s">"#43958D"</span> <span class="na">topScale=</span><span class="s">"0.7"</span> <span class="na">bottomScale=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
        ...
    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span></pre></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-18200" data-y="35400" data-z="0"><h1 id="id37">Generic scene</h1><h2 id="logging">Logging</h2><ul><li>The output log is redirected to the current working directory <strong>Ogre.log</strong></li><li>Very important for debugging materials and shaders</li></ul></div><div class="step step-level-1 title" step="45" data-x="-20200" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-y="35400" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="adaptors">Adaptors</h1></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-22200" data-y="35400" data-z="0"><h1 id="generic-scene-adaptors">Generic scene - Adaptors</h1><h2 id="stransform">STransform</h2><ul><li>Work on a <em>::fwData::TransformationMatrix3D</em></li><li>Wrap a <em>::Ogre::SceneNode</em></li><li>A parent transform can be specified, thus allowing to build a scene graph implicitly</li></ul><pre class="highlight code xml"><span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"mesh"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTransform"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"tfAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::STransform"</span> <span class="na">objectId=</span><span class="s">"meshTF"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTransform"</span> <span class="na">parentTransform=</span><span class="s">"parentTransform"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"parentAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::STransform"</span> <span class="na">objectId=</span><span class="s">"parentTF"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"parentTransform"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span></pre></div><div class="step step-level-1" step="47" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-24200" data-y="35400" data-z="0"><h1 id="id38">Generic scene - Adaptors</h1><h2 id="smesh">SMesh</h2><ul><li>Work on a <em>::fwData::Mesh</em></li><li>Instantiated in XML, but also automatically by <em>::visuOgreAdaptor::SModelSeries</em></li><li>Copy meshes data into <em>::Ogre::HardwareBuffer</em> as fast as possible</li><li>Handle edges, triangles, quads or tetrahedrons primitives</li><li>Handle only meshes with cells data (indices)</li><li>Handle vertex normals, vertex texture coordinates, vertex colors and primitive colors</li></ul></div><div class="step step-level-1" step="48" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-26200" data-y="35400" data-z="0"><h1 id="id39">Generic scene - Adaptors</h1><h2 id="smesh-implementation-details">SMesh - Implementation details</h2><ul><li>Contains a <em>::Ogre::Mesh</em> and a <em>::Ogre::Entity</em></li><li>This means that mesh data is not shared between two adaptors on the same mesh (future work)</li><li>By default, a <em>SMaterial</em> is created automatically but it can be specified in XML</li></ul><pre class="highlight code xml"><span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTransform"</span> <span class="na">materialTemplate=</span><span class="s">"Blue"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAdaptor2"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">materialAdaptor=</span><span class="s">"mtlAdaptorUID"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"mtlAdaptor"</span> <span class="na">uid=</span><span class="s">"mtlAdaptorUID"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMaterial"</span> <span class="na">objectId=</span><span class="s">"mtl"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">materialTemplate=</span><span class="s">"Red"</span> <span class="na">normalLength=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span></pre></div><div class="step step-level-1" step="49" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-28200" data-y="35400" data-z="0"><h1 id="id40">Generic scene - Adaptors</h1><h2 id="smesh-render-to-vertex-buffer">SMesh - Render-to-Vertex Buffer</h2><ul><li>Quads or tetrahedrons are not native primitive types, they must be converted into triangles</li><li>Per-primitive color is also not straightforward to implement, you need to duplicate points</li><li>Doing this in software is expensive, especially if we need to do that every frame</li><li>Take advantage of geometry shaders and Render-to-Vertex Buffer (GL_TRANSFORM_FEEDBACK)</li></ul></div><div class="step step-level-1" step="50" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-30200" data-y="35400" data-z="0"><h1 id="id41">Generic scene - Adaptors</h1><h2 id="id42">SMesh - Render-to-Vertex Buffer</h2><p>Example: quads</p><img src="images/tri_to_quad.svg" width="100%"></img></div><div class="step step-level-1" step="51" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-32200" data-y="35400" data-z="0"><h1 id="id43">Generic scene - Adaptors</h1><h2 id="id44">SMesh - Render-to-Vertex Buffer</h2><ul><li>Give the GPU the raw quads list</li><li>Let the geometry shader generate a strip of two triangles for each primitive</li></ul><pre class="highlight code glsl"><span class="n">layout</span> <span class="p">(</span><span class="n">lines_adjacency</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>

<span class="k">out</span> <span class="k">vec3</span> <span class="n">oPos</span><span class="p">;</span>

<span class="k">void</span> <span class="n">emit</span><span class="p">(</span><span class="k">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">oPos</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">EmitVertex</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">emit</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span> <span class="n">emit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">emit</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">emit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">EndPrimitive</span><span class="p">();</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="52" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-34200" data-y="35400" data-z="0"><h1 id="id45">Generic scene - Adaptors</h1><h2 id="id46">SMesh - Render-to-Vertex Buffer</h2><ul><li><dl><dt>Do we want to do that each time the object is rendered ?</dt><dd><ul><li>The geometry shader cost is real, especially if we render the object several times</li></ul></dd></dl></li><li>So, we break the GPU pipeline after the geometry shader output, just before the rasterization</li><li>The output is a vertex buffer that we can reuse when the object is rendered</li></ul></div><div class="step step-level-1" step="53" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-36200" data-y="35400" data-z="0"><h1 id="id47">Generic scene - Adaptors</h1><h2 id="id48">SMesh - Render-to-Vertex Buffer</h2><ul><li><dl><dt>We use a special <em>R2VBRenderable</em> object,</dt><dd><ul><li>Contains a <em>::Ogre::RenderToVertexBuffer</em>, which takes a ::Ogre::SubEntity as input</li></ul></dd></dl></li><li><dl><dt>When it is updated, before rendering:</dt><dd><ol><li>Render the source data into a vertex buffer</li><li>Put the result data in the render queue</li></ol></dd></dl></li></ul><div class="line-block"><br></br><br></br><br></br></div></div><div class="step step-level-1 centered" step="54" data-x="-36100" data-y="35050" data-scale="0.5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-z="0"><img src="images/r2vb.svg" width="150%"></img></div><div class="step step-level-1" step="55" data-x="-38100" data-y="35050" data-scale="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-z="0"><h1 id="id49">Generic scene - Adaptors</h1><h2 id="smaterial">SMaterial</h2><ul><li>Work on a ::fwData::Material</li><li>Instantiated by SMesh or configured by XML</li><li>Wrap a <em>::Ogre::Material</em></li></ul><pre class="highlight code xml"><span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAd"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">materialAdaptor=</span><span class="s">"mtlAdUID"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"mtlAd"</span> <span class="na">uid=</span><span class="s">"mtlAdUID"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMaterial"</span> <span class="na">objectId=</span><span class="s">"mtl"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">materialTemplate=</span><span class="s">"Red"</span> <span class="na">normalLength=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span></pre></div><div class="step step-level-1" step="56" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-40100" data-y="35050" data-z="0"><h1 id="id50">Generic scene - Adaptors</h1><h2 id="id51">SMaterial</h2><ul><li><dl><dt><em>::Ogre::Material</em> is loaded</dt><dd><ul><li>from a script on disk</li><li>into the resource group <strong>"materialsTemplate"</strong></li></ul></dd></dl></li><li>We create a copy of the template material, thus we can modify it without altering other objects which use this material</li></ul></div><div class="step step-level-1" step="57" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-42100" data-y="35050" data-z="0"><h1 id="id52">Generic scene - Adaptors</h1><h2 id="material-scripts-registration">Material scripts registration</h2><ul><li>Either put the material in the existing material Bundle</li><li>Create a bundle and create a configuration file that indicates the resource locations :</li></ul><pre class="highlight code"># resources.cfg
[materials]
FileSystem=./Bundles/myBundle_0-1/Media/materials/</pre><ul><li>And register the configuration file :</li></ul><pre class="highlight code cpp"><span class="c1">// Plugin.cpp
</span>
<span class="cp">#define RESOURCES_PATH "./Bundles/myBundle_0-1/resources.cfg"
</span>
<span class="kt">void</span> <span class="n">Plugin</span><span class="o">::</span><span class="n">start</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span><span class="o">::</span><span class="n">fwRuntime</span><span class="o">::</span><span class="n">RuntimeException</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">::</span><span class="n">fwRenderOgre</span><span class="o">::</span><span class="n">Utils</span><span class="o">::</span><span class="n">addResourcesPath</span><span class="p">(</span> <span class="n">RESOURCES_PATH</span> <span class="p">);</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="58" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-44100" data-y="35050" data-z="0"><h1 id="id53">Generic scene - Adaptors</h1><h2 id="default-material">Default material</h2><ul><li><em>Default</em> is the main material</li><li><dl><dt>It replaces the fixed function pipeline we had with VTK:</dt><dd><ul><li>Flat/Gouraud/Diffuse shading</li><li>Point/WireFrame/Solid fill modes</li><li>Vertex color, diffuse texture</li></ul></dd></dl></li><li>Supports OIT (Order Independent Transparency) techniques</li></ul></div><div class="step step-level-1" step="59" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-46100" data-y="35050" data-z="0"><h1 id="id54">Generic scene - Adaptors</h1><h2 id="negato">Negato</h2><ul><li>Two services SNegato2D and SNegato3D</li><li>Work on a <em>::fwData::Image</em></li><li>Optional bilinear filtering supported</li><li>Transfer function will be supported soon</li><li>Interactions in 2D managed by a specific interactor <em>::fwRenderOgre::Negato2DInteractor</em></li><li>Use of textured planes ( <em>::fwRenderOgre::Plane</em> )</li></ul></div><div class="step step-level-1" step="60" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-48100" data-y="35050" data-z="0"><h1 id="id55">Generic scene - Adaptors</h1><h2 id="negato-implementation-details">Negato - Implementation details</h2><ul><li><dl><dt>The 3D image is uploaded entirely to the GPU in a 3D texture</dt><dd><ul><li>normalized unsigned integer texture format</li><li>cheap hardware bilinear interpolation (raw integer formats can't be filtered in OpenGL)</li><li>slower copy in CPU (conversion from signed to unsigned)</li></ul></dd></dl></li><li><dl><dt>Sampling is done in a fragment shader</dt><dd><ul><li>conversion from unsigned to signed</li><li>interpolation and transfer function fetch (WIP)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="61" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-50100" data-y="35050" data-z="0"><h1 id="id56">Generic scene - Adaptors</h1><h2 id="textures">Textures</h2><ul><li>Work on a <em>::fwData::Image</em></li><li>Wrap a ::Ogre::Texture</li><li>Currently only used as a diffuse texture</li><li>Static or dynamic texture</li></ul></div><div class="step step-level-1" step="62" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-52100" data-y="35050" data-z="0"><h1 id="id57">Generic scene - Adaptors</h1><h2 id="sshaderparameter">SShaderParameter</h2><ul><li><dl><dt>Work on several data :</dt><dd><ul><li><em>::fwData::Integer</em></li><li><em>::fwData::Float</em></li><li><em>::fwData::Boolean</em></li><li><em>::fwData::Color</em></li><li><em>::fwData::PointList</em></li><li><em>::fwData::TransformationMatrix3D</em></li><li><em>::fwData::Vector</em></li></ul></dd></dl></li><li>Upload the data as a program uniform</li></ul></div><div class="step step-level-1 title" step="63" data-x="-54100" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-y="35050" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="transparency">Transparency</h1></div><div class="step step-level-1" step="64" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-56100" data-y="35050" data-z="0"><h1 id="id58">Transparency</h1><h2 id="order-independent-transparency">Order Independent Transparency</h2><ul><li><dl><dt>GPU hardware only supports alpha blending</dt><dd><ul><li>Order dependent</li></ul></dd></dl></li><li><dl><dt>We support four different OIT techniques with <em>Default</em> and <em>Negato</em> materials:</dt><dd><ul><li>Depth Peeling (exact but slow)</li><li>Dual Depth Peeling (normally faster)</li><li>Weighted-Order Independent Transparency (fastest)</li><li>Hybrid Transparency (nice tradeoff)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="65" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-58100" data-y="35050" data-z="0"><h1 id="id59">Transparency</h1><h2 id="implementation">1/ Implementation</h2><ul><li><dl><dt>Use of compositors with lots of passes</dt><dd><ul><li>Example: one compositor pass for each peel in the Depth Peeling algorithm</li></ul></dd></dl></li><li><dl><dt>The scene is rendered several times</dt><dd><ul><li>Specific code for the transparency</li><li>Common code for the lighting</li></ul></dd></dl></li><li><dl><dt>Technique schemes are used to select the appropriate code</dt><dd><ul><li>The material must implement <strong>all</strong> the schemes to support all the OIT techniques !</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="66" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-60100" data-y="35050" data-z="0"><h1 id="id60">Transparency</h1><h2 id="id61">2/ Implementation</h2><ul><li><dl><dt>Share the common code:</dt><dd><ul><li>No standard <strong>#include</strong> in GLSL</li><li>Use of <strong>attach</strong> in Ogre material program</li><li>Example:</li></ul></dd></dl></li></ul><pre class="highlight code">fragment_program DepthPeeling_peel_Ambient_FP_glsl glsl
{
    source DepthPeelingPeel_FP.glsl
    attach DepthPeelingCommon_FP
    attach MaterialColor_Ambient_FP

    default_params
    {
        param_named u_fragData0 int 0
        param_named_auto u_vpWidth viewport_width
        param_named_auto u_vpHeight viewport_height
        param_named_auto u_diffuse surface_diffuse_colour
    }
}</pre></div><div class="step step-level-1" step="67" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-62100" data-y="35050" data-z="0"><h1 id="id62">Transparency</h1><h2 id="id63">3/ Implementation</h2><ul><li><dl><dt>Preprocess the common code:</dt><dd><ul><li>Use of <strong>preprocessor_defines</strong> in Ogre material program</li><li>Example:</li></ul></dd></dl></li></ul><pre class="highlight code">// .material
fragment_program Lighting_FP glsl
{
    source Lighting.glsl
    preprocessor_defines LIGHTING_ENABLED=1,NUM_LIGHTS=10
}</pre><pre class="highlight code glsl"><span class="c1">// Lighting.glsl</span>
<span class="p">...</span>
<span class="cp">#ifdef LIGHTING_ENABLED</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">u_lightDir</span><span class="p">[</span><span class="n">NUM_LIGHTS</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">...</span></pre></div><div class="step step-level-1" step="68" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-64100" data-y="35050" data-z="0"><h1 id="id64">Transparency</h1><h2 id="id65">4/ Implementation</h2><ul><li><dl><dt>Lots of combination to handle for each scheme (more than 200 combinations) :</dt><dd><ul><li>lighting : Ambient/Flat/Gouraud/Phong</li><li>vertex color : on/off</li><li>primitive color : on/off</li><li>diffuse texture : on/off</li><li>edge/normal display</li></ul></dd></dl></li><li>We switch the programs at runtime (in <em>SMaterial</em>)</li><li>The GLSL code is shared as much as possible (less than 20 .glsl) files</li><li>Still, around 200 material programs to define all the combinations !</li></ul></div><div class="step step-level-1" step="69" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-66100" data-y="35050" data-z="0"><h1 id="id66">Transparency</h1><h2 id="id67">5/ Implementation</h2><ul><li><dl><dt>Generation of the material programs with a <strong>Python</strong> script using <strong>Jinja</strong> templating</dt><dd><ul><li><strong>materials/genMaterials.py</strong></li></ul></dd></dl></li><li>Template: <strong>materials/templates/Common.program.tpl</strong></li><li>Generated file: <strong>materials/Common.program</strong></li><li>Less error-prone</li><li>Not easy to understand in a first place, but clearer at the end</li><li>Not extensible to materials defined</li></ul></div><div class="step step-level-1 overview" step="70" data-x="-66100" data-y="32350" data-rotate-z="270" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="id68">Overview</h1><ul><li><dl><dt>Ogre 3D</dt><dd><ul><li>Architecture overview</li><li>Scripting</li></ul></dd></dl></li><li><dl><dt>Generic scene</dt><dd><ul><li>Architecture</li><li>Basics</li><li>Adaptors</li><li>Transparency</li></ul></dd></dl></li><li>Perspectives</li><li><dl><dt><em>Tutorials</em></dt><dd><ul><li>Material</li><li>Compositors</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="71" data-x="-66100" data-y="30350" data-rotate-z="270" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="perspectives">Perspectives</h1><ul><li>Enhance new material integration with OIT</li><li>Unit testing</li><li>Volume rendering</li><li>SAO with transparency</li><li>Better visualizations for Augmented Reality</li><li>New adaptors</li><li>Helper drawing class</li><li>3D Widgets</li><li>Diffuse/specular shading</li><li>Post Effects</li><li>Ogre 2.0/2.1 ?</li><li>...</li></ul></div><div class="step step-level-1 title" step="72" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="28350" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="tutorials-material">Tutorials - Material</h1></div><div class="step step-level-1" step="73" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="26350" data-z="0"><h1 id="tutorials">Tutorials</h1><h2 id="mesh">1/ Mesh</h2><ol><li>Grab the application skeleton on <strong>OwnCloud/PartageRD/ogre-training</strong></li><li>Add an ogre generic scene to display the liver mesh</li></ol><video width="640" height="360" controls>
   <source src="../videos/ogre-training1.ogv">
   Your browser does not support the video tag.
</video></div><div class="step step-level-1" step="74" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="24350" data-z="0"><h1 id="id69">Tutorials</h1><h2 id="texture">2/ Texture</h2><ol><li>Modify the previous application to load the liver texture with a <em>::ioVTK::SImageReader</em></li><li>Add a texture adaptor on the loaded image to map it on the liver mesh</li></ol><video width="640" height="360" controls>
   <source src="../videos/ogre-training2.ogv">
   Your browser does not support the video tag.
</video></div><div class="step step-level-1" step="75" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="22350" data-z="0"><h1 id="id70">Tutorials</h1><h2 id="new-material">3/ New Material</h2><ol><li><dl><dt>Create a bundle and register a material "toto"</dt><dd><ul><li>Check registration with <strong>Ogre.log</strong></li></ul></dd></dl></li><li><dl><dt>Create the material with a vertex shader and a fragment shader</dt><dd><ul><li>Vertex shader only transforms the points</li><li>Fragment shader lits pixels in green</li></ul></dd></dl></li></ol><ul><li><dl><dt>Tip to write the vertex shader:</dt><dd><ul><li><em>gl_Position</em> output is automatically defined <strong>RenderSystems/GL3Plus/src/GLSL/OgreGLSLShader.cpp:232</strong></li></ul></dd></dl></li></ul></div><div class="step step-level-1 text-small" step="76" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="20350" data-z="0"><h1 id="id71">Tutorials</h1><h2 id="id72">3/ New Material</h2><pre class="highlight code">//-----------------------------------------------

vertex_program toto_VP glsl
{
    source toto_VP.glsl
    default_params
    {
        param_named_auto u_worldViewProj worldviewproj_matrix
    }
}

//----------------------------------------------

vertex_program toto_FP glsl
{
    source toto_FP.glsl
}

//----------------------------------------------
material toto
{
    technique
    {
        pass
        {
            vertex_program_ref toto_VP
            {
            }

            fragment_program_ref toto_FP
            {
            }
        }
    }
}</pre></div><div class="step step-level-1" step="77" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="18350" data-z="0"><h1 id="id73">Tutorials</h1><h2 id="id74">3/ New Material</h2><video width="800" height="450" controls>
   <source src="../videos/ogre-training3.ogv">
   Your browser does not support the video tag.
</video></div><div class="step step-level-1" step="78" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="16350" data-z="0"><h1 id="id75">Tutorials</h1><h2 id="material-with-a-static-texture">4/ Material with a static texture</h2><ul><li>Modify the material to add a texture unit and bind the sampler uniform</li><li><dl><dt>Modify the vertex and fragment programs to forward the texture coordinates</dt><dd><ul><li><dl><dt>Possible vertex input attributes are:</dt><dd><ul><li><em>position</em> ( or <em>vertex</em>),</li><li><em>normal</em>,</li><li><em>colour</em>,</li><li><em>secondary_colour</em>,</li><li><em>tangent</em>,</li><li><em>binormal</em>,</li><li><em>uv#</em> (up to 8),</li><li><em>blendIndices</em>,</li><li><em>blendWeights</em></li></ul></dd></dl></li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="79" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="14350" data-z="0"><h1 id="id76">Tutorials</h1><h2 id="id77">4/ Material with a static texture</h2><ul><li>Sample the texture in the fragment program</li></ul><video width="640" height="360" controls>
   <source src="../videos/ogre-training4.ogv">
   Your browser does not support the video tag.
</video></div><div class="step step-level-1" step="80" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="12350" data-z="0"><h1 id="id78">Tutorials</h1><h2 id="material-with-diffuse-lighting">5/ Material with diffuse lighting</h2><ul><li>Modify the material to grab the light direction uniform</li></ul><p><a href="http://www.ogre3d.org/docs/manual/manual_23.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">http://www.ogre3d.org/docs/manual/manual_23.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass</a></p><ul><li>Add the normal vertex input attribute</li><li>Multiply the pixel color with the dot product of the light direction and the fragment normal</li><li><strong>Bonus:</strong> lit backfaces as well</li></ul><video width="640" height="360" controls>
   <source src="../videos/ogre-training5.ogv">
   Your browser does not support the video tag.
</video></div><div class="step step-level-1" step="81" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="10350" data-z="0"><h1 id="id79">Tutorials</h1><h2 id="material-with-user-control">6/ Material with user control</h2><ul><li>Now the vertex shader waves points away along the normal</li><li>The fragment shader waves the base color</li><li><dl><dt>Use the two types of uniform in Ogre to control the wave</dt><dd><ol><li>Automatic - use one of the time uniforms</li><li>User-defined - use <em>SShaderParameter</em> adaptor</li></ol></dd></dl></li></ul><p><a href="http://www.ogre3d.org/docs/manual/manual_23.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">http://www.ogre3d.org/docs/manual/manual_23.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass</a></p></div><div class="step step-level-1" step="82" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="8350" data-z="0"><h1 id="id80">Tutorials</h1><h2 id="id81">6/ Material with user control</h2><video width="640" height="360" controls>
   <source src="../videos/ogre-training6-1.ogv">
   Your browser does not support the video tag.
</video>

<video width="640" height="360" controls>
   <source src="../videos/ogre-training6-2.ogv">
   Your browser does not support the video tag.
</video></div><div class="step step-level-1" step="83" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="6350" data-z="0"><h1 id="id82">Tutorials</h1><h2 id="rendering-passes">7/ Rendering passes</h2><ul><li><dl><dt>Add a new pass in the material to render the liver a second time</dt><dd><ul><li>Multiplied over the previous pass, with a different color</li><li>At a different location</li></ul></dd></dl></li></ul></div><div class="step step-level-1 title" step="84" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="4350" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="tutorials-compositors">Tutorials - Compositors</h1></div><div class="step step-level-1" step="85" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="2350" data-z="0"><h1 id="id83">Tutorials</h1><h2 id="blur">1/ Blur</h2><ol><li><dl><dt>Create a compositor</dt><dd><ul><li>Don't forget to put it in a registered location !</li></ul></dd></dl></li><li><dl><dt>Apply a 5x5 Gaussian filter on the source image</dt><dd><ul><li>Sample the image with a texel offset [-5;5]</li><li>Take into account the size of the image (<strong>viewport_width</strong>, <strong>viewport_height</strong>)</li><li>Don't filter the texture image</li></ul></dd></dl></li><li><dl><dt>Enlarge your blur !</dt><dd><ul><li>"Cheat" by applying a bilinear filter on the source image</li><li>Downscale the resolution (1/4) of the render target used to perform the blur</li></ul></dd></dl></li><li><strong>Bonus:</strong> enhance the performance of the blur by using two passes: horizontal then vertical</li></ol></div><div class="step step-level-1" step="86" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="350" data-z="0"><h1 id="id84">Tutorials</h1><h2 id="id85">1/ Blur</h2><video width="800" height="450" controls>
   <source src="../videos/ogre-training7.ogv">
   Your browser does not support the video tag.
</video></div><div class="step step-level-1" step="87" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="-1650" data-z="0"><h1 id="id86">Tutorials</h1><h2 id="depth-of-field-non-optimal">2/ Depth of Field (non-optimal)</h2><ul><li>Use the model <strong>sponza.vtk</strong></li><li>Add a target in the compositor where you render the scene to compute a blur factor</li><li>Add a new material technique that matches the scheme of this pass and compute the blur factor in the vertex shader, depending on the distance :</li></ul><pre class="highlight code">blurFactor = clamp(abs(-posWorldView.z - focalDistance) / focalRange, 0.0, 1.0);</pre><ul><li>Add a last step in the compositor to modulate the blur according to the blur factor :</li></ul><pre class="highlight code">gl_FragColor = sharp + blurFactor * (blur - sharp);</pre><ul><li>Add a slider to modify the focalDistance</li></ul></div><div class="step step-level-1" step="88" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="-3650" data-z="0"><h1 id="id87">Tutorials</h1><h2 id="id88">2/ Depth of Field (non-optimal)</h2><video width="800" height="450" controls>
   <source src="../videos/ogre-training8.ogv">
   Your browser does not support the video tag.
</video></div><div class="step step-level-1 centered" step="89" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-66100" data-y="-5650" data-z="0"><h1 id="that-s-all-folks">That's all folks !</h1><div class="line-block"><br></br></div><p>fw4spl at gmail.com</p><p>fbridault at ircad.fr</p><div class="line-block"><br></br></div><blockquote><p>Presentation made with <a href="https://github.com/regebro/hovercraft">Hovercraft</a></p></blockquote></div></div><div id="hovercraft-help" class="hide"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>