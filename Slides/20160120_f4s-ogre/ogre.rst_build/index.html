<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>FW4SPL</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><meta name="author" content="Flavien Bridault"></meta><meta name="description" content="Ogre 3D integration in FW4SPL"></meta><meta name="keywords" content="presentation"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="css/presentation.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="750"><div class="step step-level-1" step="0" id="circle-no-background" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><div class="line-block"><br></br><br></br><br></br><br></br></div><h1 id="ogre-3d-in-fw4spl">Ogre 3D in FW4SPL</h1><p><strong>Flavien Bridault</strong></p><div class="line-block"><br></br><br></br></div><p><em>Training - Strasbourg, 20th January 2016</em></p></div><div class="step step-level-1 overview" step="1" data-x="2000" data-scale="1.0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-y="0" data-z="0"><h1 id="overview">Overview</h1><ul><li><dl><dt><em>Ogre 3D</em></dt><dd><ul><li>Architecture overview</li><li>Scripting</li></ul></dd></dl></li><li><dl><dt>Generic scene</dt><dd><ul><li>Architecture</li><li>Basics</li><li>Adaptors</li></ul></dd></dl></li><li><dl><dt>Tutorials</dt><dd><ul><li>Material</li><li>Compositors</li><li>Transparency</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="2" data-x="2000" data-y="2700" data-rotate-z="90" data-rotate-x="0" data-rotate-y="0" data-scale="1.0" data-z="0"><h1 id="ogre-3d">Ogre 3D</h1><h2 id="history">History</h2><ul><li>Object-Oriented Graphics Rendering Engine</li><li>Started in 2000, first release in 2005</li><li>Latest stable 1.9 (2013), preview 2.1</li><li><dl><dt>Used in free or commercial games</dt><dd><ul><li>Ankh series (2005-2009)</li><li>TorchLight I (2009)</li><li>Zombie Driver (2009)</li><li>TorchLight II (2012-2015)</li></ul></dd></dl></li></ul><div class="notes"><ul><li>Rendering Engine, not actually a game engine</li></ul></div></div><div class="step step-level-1 text-small" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="5400" data-z="0"><h1 id="id1">Ogre 3D</h1><h2 id="features">Features</h2><ul><li>High-level abstractions</li><li>Cross-platform : Windows, Linux, MacOSX and Android</li><li>Scene-graph</li><li>Resource management (meshes, textures, material/shaders)</li><li>Vertex animation (CPU and GPU)</li><li>Material LOD</li><li>Material scripting</li><li>Multipass effects</li><li>Progressive meshes (manual or auto)</li><li>Shadows (image or object-based)</li><li>Compositors</li><li>Particles system</li><li>Ribbon trails</li><li>BSP/PVS, Octree, portals</li></ul><div class="notes"><ul><li>Texture == image</li></ul></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="8100" data-z="0"><h1 id="id2">Ogre 3D</h1><h2 id="why">Why ?</h2><ul><li><dl><dt>VTK</dt><dd><ul><li>is oriented towards visualization</li><li>is far from the hardware, very high-level abstraction</li><li>does not use cutting-edge OpenGL features</li></ul></dd></dl></li><li><dl><dt>Other</dt><dd><ul><li>Unreal, Unity</li><li>Irrlicht</li><li>G3D</li></ul></dd></dl></li></ul></div><div class="step step-level-1 title" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="10800" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="architecture-overview">Architecture overview</h1></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="13500" data-z="0"><h1 id="id3">Ogre 3D</h1><h2 id="id4">Architecture overview</h2><img src="images/ogre-uml-overview.png" width="100%"></img></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="16200" data-z="0"><h1 id="id5">Ogre 3D</h1><h2 id="ogre-root">::Ogre::Root</h2><ul><li>Entry point in the Ogre system</li><li>First to be created, last to be deleted</li><li>Holds scene and resource managers</li><li>Holds the render system</li><li>Triggers the rendering of frames (continuous or on demand)</li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="18900" data-z="0"><h1 id="id6">Ogre 3D</h1><h2 id="ogre-rendersystem">::Ogre::RenderSystem</h2><ul><li>Abstraction of the underlying 3D API (DirectX/OpenGL)</li><li>Used to create render windows <em>::Ogre::RenderWindow</em></li><li><dl><dt>Instantiated dynamically by selecting a shared library</dt><dd><ul><li>DirectX9</li><li>DirectX11</li><li>OpenGL</li><li>OpenGL3+</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="21600" data-z="0"><h1 id="id7">Ogre 3D</h1><h2 id="ogre-scenemanager">::Ogre::SceneManager</h2><ul><li><dl><dt>Organize the content of the 3D scene through a graph :</dt><dd><ul><li>objects</li><li>cameras</li><li>lights</li></ul></dd></dl></li><li>Differents spatial structures used (BSP, PVS, etc...) according to the scene type</li><li>Responsible of selecting the objects to be rendered each frame</li></ul></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="24300" data-z="0"><h1 id="id8">Ogre 3D</h1><h2 id="ogre-entity">::Ogre::Entity</h2><ul><li>Movable or static object in the scene</li><li>Attached to a <em>::Ogre::SceneNode</em></li><li>Instantiation of a mesh in the 3D scene</li><li>A mesh may have multiple materials : for each <em>::Ogre::SubMesh</em>, a <em>::Ogre::SubEntity</em> is created in the entity</li></ul></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="27000" data-z="0"><h1 id="id9">Ogre 3D</h1><h2 id="ogre-material">::Ogre::Material</h2><ul><li><dl><dt>Render states</dt><dd><ul><li>depth buffer test/write</li><li>culling/mode</li><li>blending equation</li><li>polygon fill mode (point, wireframe, solid)</li><li>...</li></ul></dd></dl></li><li><dl><dt>Shader</dt><dd><ul><li>vertex</li><li>hull</li><li>domain</li><li>geometry</li><li>fragment</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="29700" data-z="0"><h1 id="id10">Ogre 3D</h1><h2 id="ogre-resourcegroupmanager">::Ogre::ResourceGroupManager</h2><ul><li><dl><dt>one for each resource type:</dt><dd><ul><li>MeshManager</li><li>MaterialManager</li><li>TextureManager</li><li>CompositorManager</li></ul></dd></dl></li><li>allows to create/load/unload/destroy resources</li><li>few direct interactions, called by other parts of the Ogre system</li></ul></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="32400" data-z="0"><h1 id="id11">Ogre 3D</h1><h2 id="id12">::Ogre::ResourceGroupManager</h2><ul><li><dl><dt>Resources are created by name, looking through registered resource locations</dt><dd><ul><li><strong>::Ogre::ResourceGroupManager::addResourceLocation()</strong></li><li>configured easily from <em>::Ogre::ConfigFile</em> (<strong>.cfg</strong>)</li></ul></dd></dl></li></ul><pre class="highlight code"># resources.cfg

[compositors]
FileSystem=./Bundles/material_0-1/Media/compositors

[materials]
FileSystem=./Bundles/material_0-1/Media/materials/
FileSystem=./Bundles/materialExt_0-1/Media/materials/

[textures]
FileSystem=./Bundles/material_0-1/Media/textures/</pre></div><div class="step step-level-1 title" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="35100" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="scripting">Scripting</h1></div><div class="step step-level-1 text-small" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="37800" data-z="0"><h1 id="id13">Ogre 3D</h1><h2 id="materials">Materials</h2><pre class="highlight code">// dummy.material

vertex_program dummy_VP glsl
{
    source dummy_VP.glsl
    default_params
    {
        param_named_auto u_worldViewProj worldviewproj_matrix
    }
}

fragment_program dummy_FP glsl
{
    source dummy_FP.glsl
}

material dummy
{
    technique
    {
        pass
        {
            cull_hardware none
            depth_write on
            polygon_mode wireframe

            vertex_program_ref dummy_VP
            {
            }

            fragment_program_ref dummy_FP
            {
            }

            texture_unit
            {
                texture image.png
            }
        }
    }
}</pre></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="40500" data-z="0"><h1 id="id14">Ogre 3D</h1><h2 id="id15">Materials</h2><ul><li>Materials are parsed from (<strong>.material</strong>) files from the registered resource locations</li><li><dl><dt>GLSL programs can be written in a <strong>.material</strong> file</dt><dd><ul><li>be careful of the parsing order if you share programs accross multiple files</li><li>they can be put in <strong>.program</strong>, read before all <strong>.material</strong></li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="43200" data-z="0"><h1 id="id16">Ogre 3D</h1><h2 id="id17">Materials</h2><ul><li>Once parsed during initialization, easy to use:</li></ul><pre class="highlight code cpp"><span class="n">entity</span><span class="o">-&gt;</span><span class="n">setMaterialName</span><span class="p">(</span><span class="s">"dummy"</span><span class="p">);</span></pre><ul><li>Documentation: <a href="http://www.ogre3d.org/docs/manual/manual_14.html#Material-Scripts">http://www.ogre3d.org/docs/manual/manual_14.html#Material-Scripts</a></li></ul></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1.0" data-x="2000" data-y="45900" data-z="0"><h1 id="id18">Ogre 3D</h1><h2 id="compositors">Compositors</h2><ul><li><dl><dt>Pipeline of successive rendering passes:</dt><dd><ul><li>geometric pass</li><li>full screen pass</li></ul></dd></dl></li></ul><img src="images/compositor_sample.svg" width="100%"></img></div><div class="step step-level-1 overview" step="19" data-x="2000" data-y="48600" data-rotate-z="180" data-rotate-x="0" data-rotate-y="0" data-scale="1.0" data-z="0"><h1 id="id19">Overview</h1><ul><li><dl><dt>Ogre 3D</dt><dd><ul><li>Architecture overview</li><li>Scripting</li></ul></dd></dl></li><li><dl><dt><em>Generic scene</em></dt><dd><ul><li>Architecture</li><li>Basics</li><li>Adaptors</li></ul></dd></dl></li><li><dl><dt>Tutorials</dt><dd><ul><li>Material</li><li>Compositors</li><li>Transparency</li></ul></dd></dl></li></ul></div><div class="step step-level-1 title" step="20" data-x="0" data-y="48600" data-rotate-z="180" data-rotate-x="0" data-rotate-y="0" data-scale="1.0" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="generic-scene-architecture">Generic scene architecture</h1></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-2000" data-y="48600" data-z="0"><h1 id="generic-scene">Generic scene</h1><h2 id="architecture">Architecture</h2><p>Same principle than our generic scene using VTK</p><ul><li>A <strong>render</strong> service, working on a ::fwData::Composite data, acts as a manager</li><li>Sub-services named as <em>adaptors</em> work on the <strong>keys</strong> of the composite</li><li>Adaptors are configured in XML or instantiated by the C++ code</li><li>The manager listens to its composite, and supervises the starting and stopping of adaptors</li><li>When an object is added/removed, the adaptor in the XML configuration is started/stopped</li></ul></div><div class="step step-level-1" step="22" data-x="-2000" data-y="47700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericSceneOgre"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        <span class="nt">&lt;background</span> <span class="na">topColor=</span><span class="s">"#DDDDDD"</span> <span class="na">bottomColor=</span><span class="s">"#43958D"</span> <span class="na">topScale=</span><span class="s">"0.7"</span> <span class="na">bottomScale=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;renderer</span> <span class="na">id=</span><span class="s">"default"</span> <span class="na">layer=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"cameraAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SCamera"</span> <span class="na">objectId=</span><span class="s">"cameraTF"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTF"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"transformAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::STransform"</span> <span class="na">objectId=</span><span class="s">"transform"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTF"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span>

<span class="nt">&lt;item</span> <span class="na">key=</span><span class="s">"cameraTF"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;object</span> <span class="na">uid=</span><span class="s">"cameraTF"</span> <span class="na">type=</span><span class="s">"::fwData::TransformationMatrix3D"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/item&gt;</span>

<span class="nt">&lt;item</span> <span class="na">key=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;object</span> <span class="na">uid=</span><span class="s">"meshUid"</span> <span class="na">type=</span><span class="s">"::fwData::Mesh"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/item&gt;</span>

<span class="nt">&lt;item</span> <span class="na">key=</span><span class="s">"transform"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;object</span> <span class="na">uid=</span><span class="s">"transformUid"</span> <span class="na">type=</span><span class="s">"::fwData::TransformationMatrix3D"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/item&gt;</span></pre></div><div class="step step-level-1 text-medium" step="23" data-x="-4000" data-y="47700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"><h1 id="id20">Generic scene</h1><h2 id="library-design">Library design</h2><ul><li><dl><dt>the library <em>fwRenderOgre</em> contains the core</dt><dd><ul><li>SRender service</li><li>Interactors</li></ul></dd></dl></li><li>the bundle <em>visu</em> allows to register SRender</li><li>the bundle <em>visuOgreQt</em> contains the Qt widget and its interactions</li><li><dl><dt>the bundle <em>visuOgreAdaptor</em> contains the core adaptors</dt><dd><ul><li>SCamera</li><li>STransform</li><li>SMesh</li><li>SMaterial</li><li>SNegato</li><li>STexture</li><li>...</li></ul></dd></dl></li></ul></div><div class="step step-level-1 title" step="24" data-x="-6000" data-y="47700" data-rotate-z="180" data-rotate-x="0" data-rotate-y="0" data-scale="1.0" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="basics">Basics</h1></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-8000" data-y="47700" data-z="0"><h1 id="id21">Generic scene</h1><h2 id="windowing-management">Windowing management</h2><img src="images/srender_interactor.svg" width="100%"></img></div><div class="step step-level-1" step="26" data-x="-8000" data-y="48700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"><h1 id="id22">Generic scene</h1><h2 id="visuogreqt-window">::visuOgreQt::Window</h2><ul><li><dl><dt>Create and manage the RenderWindow</dt><dd><ul><li>There is some shi**** platform-specific code</li></ul></dd></dl></li><li>Responsible of triggering the rendering (on-demand)</li><li>Receive mouse and keyboards interactions, forward them to the RenderWindowInteractorManager</li></ul></div><div class="step step-level-1" step="27" data-x="-8000" data-y="47700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"></div><div class="step step-level-1" step="28" data-x="-8000" data-y="46700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"><h1 id="id23">Generic scene</h1><h2 id="visuogreqt-renderwindowinteractormanager">::visuOgreQt::RenderWindowInteractorManager</h2><ul><li>Create ::visuOgreQt::Window and place it the GUI layout</li><li><dl><dt>Manage communication with Qt and fw4spl slots</dt><dd><ul><li><em>::fwRenderOgre::SRender</em></li><li><em>::visuOgreQt::Window</em></li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="29" data-x="-8000" data-y="47700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"></div><div class="step step-level-1" step="30" data-x="-9500" data-y="47700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"><h1 id="id24">Generic scene</h1><h2 id="fwrenderogre-srender">::fwRenderOgre::SRender</h2><ul><li>Contains and manage the adaptors</li><li>Bridge between the adaptors and the widget</li><li>With <strong>makeCurrent()</strong>, allows the adaptors to set the current OpenGL context</li><li>With <strong>requestRender()</strong>, allows the adaptors to refresh the rendering</li></ul></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-11000" data-y="47700" data-z="0"><h1 id="id25">Generic scene</h1><h2 id="layers">Layers</h2><img src="images/srender_layer.svg" width="100%"></img></div><div class="step step-level-1" step="32" data-x="-11000" data-y="48700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"><h1 id="id26">Generic scene</h1><h2 id="layer">Layer</h2><ul><li>Allows to have multiple scenes in a window</li><li>A scene is rendered individually in a render target (<em>::Ogre::Viewport</em>)</li><li>The output is only a color texture, thus SRender composite them at the end</li></ul><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericScene"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        <span class="nt">&lt;renderer</span> <span class="na">id=</span><span class="s">"video"</span> <span class="na">layer=</span><span class="s">"1"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;renderer</span> <span class="na">id=</span><span class="s">"scene"</span> <span class="na">layer=</span><span class="s">"2"</span> <span class="nt">/&gt;</span>
        ...

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"videoAdapter"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SVideo"</span> <span class="na">objectId=</span><span class="s">"image"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"video"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"modelSeries"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SModelSeries"</span> <span class="na">objectId=</span><span class="s">"model"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"scene"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>

    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span></pre></div><div class="step step-level-1" step="33" data-x="-11000" data-y="47700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"></div><div class="step step-level-1" step="34" data-x="-11000" data-y="46700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"><h1 id="id27">Generic scene</h1><h2 id="interactors">Interactors</h2><ul><li><dl><dt>Two types :</dt><dd><ul><li>How to pick objects : mesh, video</li><li>How to move the camera : trackball, fixed, negato2D</li></ul></dd></dl></li><li>Selected with <em>::visuOgreAdaptor::SInteractorStyle</em></li></ul><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericScene"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        ...
        <span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"adaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SInteractorStyle"</span> <span class="na">objectId=</span><span class="s">"self"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">style=</span><span class="s">"Trackball"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/adaptor&gt;</span>
        ...
    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span></pre></div><div class="step step-level-1" step="35" data-x="-11000" data-y="47700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"></div><div class="step step-level-1" step="36" data-x="-12500" data-y="47700" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-z="0"><h1 id="id28">Generic scene</h1><h2 id="id29">Compositors</h2><ul><li>DefaultCompositor handles the "core" compositors, like those related to transparency</li><li>Each layer has a compositor chain managed by a <em>CompositorChainManager</em>, designed to receive custom compositors</li></ul><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericScene"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        <span class="nt">&lt;renderer</span> <span class="na">id=</span><span class="s">"video"</span> <span class="na">layer=</span><span class="s">"1"</span> <span class="na">compositors=</span><span class="s">"Laplace;ASCII;Bloom"</span> <span class="nt">/&gt;</span>
        ...
    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span></pre></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-14000" data-y="47700" data-z="0"><h1 id="id30">Generic scene</h1><h2 id="background">Background</h2><ul><li>Special layer #0, instantiated in SRender</li><li>Can be filled with a gradient</li></ul><pre class="highlight code xml"><span class="nt">&lt;service</span> <span class="na">uid=</span><span class="s">"genericScene"</span> <span class="na">impl=</span><span class="s">"::fwRenderOgre::SRender"</span> <span class="na">autoConnect=</span><span class="s">"yes"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;scene&gt;</span>
        <span class="nt">&lt;background</span> <span class="na">topColor=</span><span class="s">"#DDDDDD"</span> <span class="na">bottomColor=</span><span class="s">"#43958D"</span> <span class="na">topScale=</span><span class="s">"0.7"</span> <span class="na">bottomScale=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
        ...
    <span class="nt">&lt;/scene&gt;</span>
<span class="nt">&lt;/service&gt;</span></pre></div><div class="step step-level-1 title" step="38" data-x="-16000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-y="47700" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="adaptors">Adaptors</h1></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-18000" data-y="47700" data-z="0"><h1 id="generic-scene-adaptors">Generic scene - Adaptors</h1><h2 id="stransform">STransform</h2><ul><li>Work on a <em>::fwData::TransformationMatrix3D</em></li><li>Wraps a <em>::Ogre::SceneNode</em></li><li>A parent transform can be specified, thus allowing to build a scene graph implicitly</li></ul><pre class="highlight code xml"><span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"mesh"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTransform"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"tfAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::STransform"</span> <span class="na">objectId=</span><span class="s">"meshTF"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTransform"</span> <span class="na">parentTransform=</span><span class="s">"parentTransform"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"parentAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::STransform"</span> <span class="na">objectId=</span><span class="s">"parentTF"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"parentTransform"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span></pre></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-20000" data-y="47700" data-z="0"><h1 id="id31">Generic scene - Adaptors</h1><h2 id="smesh">SMesh</h2><ul><li>Work on a <em>::fwData::Mesh</em></li><li>Instantiated in XML, but also automatically by <em>::visuOgreAdaptor::SModelSeries</em></li><li>Copy meshes data into <em>::Ogre::HardwareBuffer</em> as fast as possible</li><li>Handle edges, triangles, quads or tetrahedrons primitives</li><li>Handle only meshes with cells data (indices)</li><li>Handle vertex normals, vertex texture coordinates, vertex colors and primitive colors</li></ul></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-22000" data-y="47700" data-z="0"><h1 id="id32">Generic scene - Adaptors</h1><h2 id="smesh-implementation-details">SMesh - Implementation details</h2><ul><li>Contains a <em>::Ogre::Mesh</em> and a <em>::Ogre::Entity</em></li><li>This means that mesh data is not shared between two adaptors on the same mesh (future work)</li><li>By default, a <em>SMaterial</em> is created automatically but it can be specified in XML</li></ul><pre class="highlight code xml"><span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAdaptor"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">transform=</span><span class="s">"meshTransform"</span> <span class="na">materialTemplate=</span><span class="s">"Blue"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAdaptor2"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">materialAdaptor=</span><span class="s">"mtlAdaptorUID"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"mtlAdaptor"</span> <span class="na">uid=</span><span class="s">"mtlAdaptorUID"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMaterial"</span> <span class="na">objectId=</span><span class="s">"mtl"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">materialTemplate=</span><span class="s">"Red"</span> <span class="na">normalLength=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span></pre></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-24000" data-y="47700" data-z="0"><h1 id="id33">Generic scene - Adaptors</h1><h2 id="smesh-render-to-vertex-buffer">SMesh - Render-to-Vertex Buffer</h2><ul><li>Quads or tetrahedrons are not native primitive types, they must be converted into triangles</li><li>Per-primitive color is also not straightforward to implement, you need to duplicate points</li><li>Doing this in software is expensive, especially if we need to do that every frame</li><li>Take advantage of geometry shaders and Render-to-Vertex Buffer (GL_TRANSFORM_FEEDBACK)</li></ul></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-26000" data-y="47700" data-z="0"><h1 id="id34">Generic scene - Adaptors</h1><h2 id="id35">SMesh - Render-to-Vertex Buffer</h2><p>Example: quads</p><img src="images/tri_to_quad.svg" width="100%"></img></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-28000" data-y="47700" data-z="0"><h1 id="id36">Generic scene - Adaptors</h1><h2 id="id37">SMesh - Render-to-Vertex Buffer</h2><ul><li>Give the GPU the raw quads list</li><li>Let the geometry shader generate a strip of two triangles for each primitive</li></ul><pre class="highlight code glsl"><span class="n">layout</span> <span class="p">(</span><span class="n">lines_adjacency</span><span class="p">)</span> <span class="k">in</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">out</span><span class="p">;</span>

<span class="k">out</span> <span class="k">vec3</span> <span class="n">oPos</span><span class="p">;</span>

<span class="k">void</span> <span class="n">emit</span><span class="p">(</span><span class="k">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">oPos</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">EmitVertex</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">emit</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span> <span class="n">emit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">emit</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">emit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">EndPrimitive</span><span class="p">();</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="45" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-30000" data-y="47700" data-z="0"><h1 id="id38">Generic scene - Adaptors</h1><h2 id="id39">SMesh - Render-to-Vertex Buffer</h2><ul><li><dl><dt>Do we want to do that each time the object is rendered ?</dt><dd><ul><li>The geometry shader cost is real, especially if we render the object several times</li></ul></dd></dl></li><li>So, we break the GPU pipeline after the geometry shader output, just before the rasterization</li><li>The output is a vertex buffer that we can reuse when the object is rendered</li></ul></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1.0" data-x="-32000" data-y="47700" data-z="0"><h1 id="id40">Generic scene - Adaptors</h1><h2 id="id41">SMesh - Render-to-Vertex Buffer</h2><ul><li><dl><dt>We use a special <em>R2VBRenderable</em> object,</dt><dd><ul><li>Contains a <em>::Ogre::RenderToVertexBuffer</em>, which takes a ::Ogre::SubEntity as input</li></ul></dd></dl></li><li><dl><dt>When it is updated, before rendering:</dt><dd><ol><li>Render the source data into a vertex buffer</li><li>Put the result data in the render queue</li></ol></dd></dl></li></ul><div class="line-block"><br></br><br></br><br></br></div></div><div class="step step-level-1 centered" step="47" data-x="-31900" data-y="47350" data-scale="0.5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-z="0"><img src="images/r2vb.svg" width="150%"></img></div><div class="step step-level-1" step="48" data-x="-33900" data-y="47350" data-scale="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-z="0"><h1 id="id42">Generic scene - Adaptors</h1><h2 id="smaterial">SMaterial</h2><ul><li>Work on a ::fwData::Material</li><li>Instantiated by SMesh or configured by XML</li><li>Wraps a <em>::Ogre::Material</em></li></ul><pre class="highlight code xml"><span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"meshAd"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMesh"</span> <span class="na">objectId=</span><span class="s">"meshKey"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">materialAdaptor=</span><span class="s">"mtlAdUID"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span>

<span class="nt">&lt;adaptor</span> <span class="na">id=</span><span class="s">"mtlAd"</span> <span class="na">uid=</span><span class="s">"mtlAdUID"</span> <span class="na">class=</span><span class="s">"::visuOgreAdaptor::SMaterial"</span> <span class="na">objectId=</span><span class="s">"mtl"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;config</span> <span class="na">renderer=</span><span class="s">"default"</span> <span class="na">materialTemplate=</span><span class="s">"Red"</span> <span class="na">normalLength=</span><span class="s">"1.0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/adaptor&gt;</span></pre></div><div class="step step-level-1" step="49" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-35900" data-y="47350" data-z="0"><h1 id="id43">Generic scene - Adaptors</h1><h2 id="id44">SMaterial</h2><ul><li><dl><dt><em>::Ogre::Material</em> is loaded</dt><dd><ul><li>from a script on disk</li><li>into the resource group <strong>"materialsTemplate"</strong></li></ul></dd></dl></li><li>We create a copy of the template material, thus we can modify it without altering other objects which use this material</li></ul></div><div class="step step-level-1" step="50" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-37900" data-y="47350" data-z="0"><h1 id="id45">Generic scene - Adaptors</h1><h2 id="default-material">Default material</h2><ul><li><em>1 - Default</em> is the main material</li><li><dl><dt>It replaces the fixed function pipeline we had with VTK:</dt><dd><ul><li>Flat/Gouraud/Diffuse shading</li><li>Point/WireFrame/Solid fill modes</li><li>Vertex color, diffuse texture</li></ul></dd></dl></li><li>Supports OIT (Order Independent Transparency) techniques</li></ul></div><div class="step step-level-1" step="51" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-39900" data-y="47350" data-z="0"><h1 id="id46">Generic scene - Adaptors</h1><h2 id="material-scripts-registration">Material scripts registration</h2><ul><li>Either put the material in the existing material Bundle</li><li>Create a bundle and create a configuration file that indicates the resource locations :</li></ul><pre class="highlight code"># resources.cfg
[materials]
FileSystem=./Bundles/myBundle_0-1/Media/materials/</pre><ul><li>And register the configuration file :</li></ul><pre class="highlight code cpp"><span class="c1">// Plugin.cpp
</span>
<span class="cp">#define RESOURCES_PATH "./Bundles/myBundle_0-1/resources.cfg"
</span>
<span class="kt">void</span> <span class="n">Plugin</span><span class="o">::</span><span class="n">start</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span><span class="o">::</span><span class="n">fwRuntime</span><span class="o">::</span><span class="n">RuntimeException</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">::</span><span class="n">fwRenderOgre</span><span class="o">::</span><span class="n">Utils</span><span class="o">::</span><span class="n">addResourcesPath</span><span class="p">(</span> <span class="n">RESOURCES_PATH</span> <span class="p">);</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="52" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-41900" data-y="47350" data-z="0"><h1 id="id47">Generic scene - Adaptors</h1><h2 id="negato">Negato</h2><ul><li>Two services SNegato2D and SNegato3D</li><li>Work on a <em>::fwData::Image</em></li><li>Optional bilinear filtering supported</li><li>Transfer function will be supported soon</li><li>Interactions in 2D managed by a specific interactor <em>::fwRenderOgre::Negato2DInteractor</em></li><li>Use of textured planes ( <em>::fwRenderOgre::Plane</em> )</li></ul></div><div class="step step-level-1" step="53" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-43900" data-y="47350" data-z="0"><h1 id="id48">Generic scene - Adaptors</h1><h2 id="negato-implementation-details">Negato - Implementation details</h2><ul><li><dl><dt>The 3D image is uploaded entirely to the GPU in a 3D texture</dt><dd><ul><li>normalized unsigned integer texture format</li><li>cheap hardware bilinear interpolation (raw integer formats can't be filtered in OpenGL)</li><li>slower copy in CPU (conversion from signed to unsigned)</li></ul></dd></dl></li><li><dl><dt>Sampling is done in a fragment shader</dt><dd><ul><li>conversion from unsigned to signed</li><li>interpolation and transfer function fetch (WIP)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="54" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-45900" data-y="47350" data-z="0"><h1 id="id49">Generic scene - Adaptors</h1><h2 id="textures">Textures</h2><ul><li>Work on a <em>::fwData::Image</em></li><li>Wraps a ::Ogre::Texture</li><li>Currently only used as a diffuse texture</li></ul></div><div class="step step-level-1" step="55" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-47900" data-y="47350" data-z="0"><h1 id="id50">Generic scene - Adaptors</h1><h2 id="sshaderparameter">SShaderParameter</h2><ul><li><dl><dt>Work on several data :</dt><dd><ul><li>::fwData::Integer</li><li>::fwData::Float</li><li>::fwData::Boolean</li><li>::fwData::Color</li><li>::fwData::PointList</li><li>::fwData::TransformationMatrix3D</li><li>::fwData::Vector</li></ul></dd></dl></li><li>Upload the data as a program uniform</li></ul></div><div class="step step-level-1 overview" step="56" data-x="-47900" data-y="44650" data-rotate-z="270" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="id51">Overview</h1><ul><li><dl><dt>Ogre 3D</dt><dd><ul><li>Architecture overview</li><li>Scripting</li></ul></dd></dl></li><li><dl><dt>Generic scene</dt><dd><ul><li>Architecture</li><li>Basics</li><li>Adaptors</li></ul></dd></dl></li><li><dl><dt><em>Tutorials</em></dt><dd><ul><li>Material</li><li>Compositors</li><li>Transparency</li></ul></dd></dl></li></ul></div><div class="step step-level-1 title" step="57" data-x="-47900" data-y="42650" data-rotate-z="270" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="tutorials-material">Tutorials - Material</h1></div><div class="step step-level-1" step="58" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="40650" data-z="0"><h1 id="tutorials">Tutorials</h1><h2 id="mesh">1/ Mesh</h2><ol><li>Grab the application skeleton on <strong>OwnCloud/PartageRD/ogre-training</strong></li><li>Add an ogre generic scene to display the liver mesh</li></ol></div><div class="step step-level-1" step="59" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="38650" data-z="0"><h1 id="id52">Tutorials</h1><h2 id="texture">2/ Texture</h2><ol><li>Modify the previous application to load the liver texture with a <em>::ioVTK::SImageReader</em></li><li>Add a texture adaptor on the loaded image to map it on the liver mesh</li></ol></div><div class="step step-level-1" step="60" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="36650" data-z="0"><h1 id="id53">Tutorials</h1><h2 id="new-material">3/ New Material</h2><ol><li><dl><dt>Create a bundle and register a material "toto"</dt><dd><ul><li>Check registration with Ogre.log</li></ul></dd></dl></li><li><dl><dt>Create the material with a vertex shader and a fragment shader</dt><dd><ul><li>Vertex shader only transform the points</li><li>Fragment shader lit pixels in green</li></ul></dd></dl></li></ol><ul><li><dl><dt>Tip to write the vertex shader:</dt><dd><ul><li><em>gl_Position</em> output is automatically defined <strong>RenderSystems/GL3Plus/src/GLSL/OgreGLSLShader.cpp:232</strong></li></ul></dd></dl></li></ul></div><div class="step step-level-1 text-small" step="61" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="34650" data-z="0"><h1 id="id54">Tutorials</h1><h2 id="id55">3/ New Material</h2><pre class="highlight code">//-----------------------------------------------

vertex_program toto_VP glsl
{
    source toto_VP.glsl
    default_params
    {
        param_named_auto u_worldViewProj worldviewproj_matrix
    }
}

//----------------------------------------------

vertex_program toto_FP glsl
{
    source toto_FP.glsl
}

//----------------------------------------------
material toto
{
    technique
    {
        pass
        {
            vertex_program_ref toto_VP
            {
            }

            fragment_program_ref toto_FP
            {
            }
        }
    }
}</pre></div><div class="step step-level-1" step="62" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="32650" data-z="0"><h1 id="id56">Tutorials</h1><h2 id="material-with-a-static-texture">4/ Material with a static texture</h2><ul><li>Modify the material to add a texture unit</li><li><dl><dt>Modify the vertex and fragment programs to forward the texture coordinates</dt><dd><ul><li><dl><dt>Possible vertex input attributes are:</dt><dd><ul><li><em>position</em> ( or <em>vertex</em>),</li><li><em>normal</em>,</li><li><em>colour</em>,</li><li><em>secondary_colour</em>,</li><li><em>tangent</em>,</li><li><em>binormal</em>,</li><li><em>uv#</em> (up to 8),</li><li><em>blendIndices</em>,</li><li><em>blendWeights</em></li></ul></dd></dl></li></ul></dd></dl></li><li>Sample the texture in the fragment program</li></ul></div><div class="step step-level-1" step="63" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="30650" data-z="0"><h1 id="id57">Tutorials</h1><h2 id="material-with-diffuse-lighting">5/ Material with diffuse lighting</h2><ul><li>Modify the material to grab the light direction uniform</li></ul><p><a href="http://www.ogre3d.org/docs/manual/manual_23.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">http://www.ogre3d.org/docs/manual/manual_23.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass</a></p><ul><li>Add the normal vertex input attribute</li><li>Multiply the pixel color with the dot product of the light direction and the fragment normal</li><li>Bonus: lit backfaces as well</li></ul></div><div class="step step-level-1" step="64" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="28650" data-z="0"><h1 id="id58">Tutorials</h1><h2 id="material-with-user-control">6/ Material with user control</h2><ul><li>Now the vertex shader wave points away along the normal</li><li>The fragment shader wave the base color</li><li><dl><dt>Use the two types of uniform in Ogre to control the wave</dt><dd><ol><li>Automatic - use one of the time uniforms</li><li>User-defined - use <em>SShaderParameter</em> adaptor</li></ol></dd></dl></li></ul><p><a href="http://www.ogre3d.org/docs/manual/manual_23.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">http://www.ogre3d.org/docs/manual/manual_23.html#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass</a></p></div><div class="step step-level-1" step="65" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="26650" data-z="0"><h1 id="id59">Tutorials</h1><h2 id="passes">7/ Passes</h2><ul><li>Add a new pass in the material to render the liver a second time</li></ul></div><div class="step step-level-1 title" step="66" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="24650" data-z="0"><div class="line-block"><br></br><br></br><br></br></div><h1 id="tutorials-compositors">Tutorials - Compositors</h1></div><div class="step step-level-1" step="67" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="22650" data-z="0"><h1 id="id60">Tutorials</h1><h2 id="blur">1/ Blur</h2><ol><li><dl><dt>Create a compositor</dt><dd><ul><li>Don't forget to put it in a registered location !</li></ul></dd></dl></li><li><dl><dt>Apply a 5x5 Gaussian filter on the source image</dt><dd><ul><li>Sample the image with a texel offset [-5;5]</li><li>Take into account the size of the image (<strong>viewport_width</strong>, <strong>viewport_height</strong>)</li><li>Don't filter the texture image</li></ul></dd></dl></li><li><dl><dt>Enlarge your blur !</dt><dd><ul><li>"Cheat" by applying a bilinear filter on the source image</li><li>Downscale the resolution of the render target used to perform the blur</li></ul></dd></dl></li></ol></div><div class="step step-level-1 centered" step="68" data-rotate-x="0" data-rotate-y="0" data-rotate-z="270" data-scale="1" data-x="-47900" data-y="20650" data-z="0"><h1 id="thank-you">Thank you !</h1><p>fw4spl at gmail.com</p><p>fbridault at ircad.fr</p><div class="line-block"><br></br><br></br></div><blockquote><p>Presentation made with <a href="https://github.com/regebro/hovercraft">Hovercraft</a></p></blockquote></div></div><div id="hovercraft-help" class="hide"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>